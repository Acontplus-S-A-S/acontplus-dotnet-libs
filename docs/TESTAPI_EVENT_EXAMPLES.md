# TestApi Event Systems Examples

This document demonstrates **both event systems** implemented in TestApi with complete examples.

## Overview

TestApi showcases two distinct event systems working together:

### 1. Domain Event Dispatcher (Transactional)
- **Purpose**: Handle operations where second insert depends on first insert's ID
- **Execution**: Synchronous, same transaction/Unit of Work
- **Use Case**: Order â†’ OrderLineItems (line items need Order.Id)

### 2. Application Event Bus (Async)
- **Purpose**: Cross-service communication, notifications, analytics
- **Execution**: Asynchronous background processing
- **Use Case**: Send email notification when order is created

---

## Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     OrderEndpoints (API Layer)                   â”‚
â”‚                  POST /api/orders/create                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                OrderService (Application Layer)                  â”‚
â”‚                                                                  â”‚
â”‚  1. Create Order entity                                          â”‚
â”‚  2. Save to database â†’ Order.Id = 123                            â”‚
â”‚                                                                  â”‚
â”‚  3. Dispatch DOMAIN EVENT (synchronous)                          â”‚
â”‚     â””â”€> EntityCreatedEvent(123, "Order")                        â”‚
â”‚                                                                  â”‚
â”‚  4. Publish APPLICATION EVENT (async)                            â”‚
â”‚     â””â”€> OrderCreatedEvent(123, "John", 99.99)                   â”‚
â”‚                                                                  â”‚
â”‚  5. SaveChangesAsync() â†’ Commits BOTH Order + LineItems          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚                           â”‚
                   â”‚                           â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚  Domain Event        â”‚    â”‚  Application Event  â”‚
       â”‚  (Synchronous)       â”‚    â”‚  (Asynchronous)     â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚                           â”‚
                   â”‚                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OrderLineItemsCreationHandler   â”‚ â”‚ OrderNotificationHandler   â”‚
â”‚ (Domain Event Handler)          â”‚ â”‚ (Background Service)       â”‚
â”‚                                 â”‚ â”‚                            â”‚
â”‚ - Runs in SAME transaction      â”‚ â”‚ - Runs async in background â”‚
â”‚ - Creates OrderLineItems        â”‚ â”‚ - Sends email notification â”‚
â”‚   using Order.Id = 123          â”‚ â”‚ - Logs analytics           â”‚
â”‚ - If fails, BOTH inserts        â”‚ â”‚ - If fails, order already  â”‚
â”‚   are rolled back               â”‚ â”‚   saved (eventual retry)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Example 1: Domain Event Dispatcher (Transactional)

### Problem Statement
**Need**: Create an Order and its OrderLineItems where line items require the Order.Id from the database.

**Challenge**: Order.Id is generated by the database on insert. How to use it for line items in the same transaction?

**Solution**: Domain Event Dispatcher runs synchronously before transaction commits.

### Code Flow

#### 1. Domain Entity (TestDomain)

```csharp
// Order.cs
public class Order : BaseEntity
{
    public required string CustomerName { get; set; }
    public required string ProductName { get; set; }
    public int Quantity { get; set; }
    public decimal Price { get; set; }
    public decimal TotalAmount { get; set; }
    public OrderStatus Status { get; set; } = OrderStatus.Created;
}

// OrderLineItem.cs - Depends on Order.Id
public class OrderLineItem : BaseEntity
{
    public int OrderId { get; set; } // â† Needs Order.Id from first insert
    public required string ProductName { get; set; }
    public int Quantity { get; set; }
    public decimal UnitPrice { get; set; }
    public decimal LineTotal { get; set; }
}
```

#### 2. Application Service (TestApplication)

```csharp
// OrderService.cs
public class OrderService
{
    private readonly IRepository<Order> _orderRepository;
    private readonly IDomainEventDispatcher _domainEventDispatcher;
    private readonly IEventPublisher _eventPublisher;

    public async Task<Result<OrderCreatedResult>> CreateOrderAsync(
        CreateOrderCommand command,
        CancellationToken cancellationToken = default)
    {
        // 1. Create Order entity
        var order = new Order
        {
            CustomerName = command.CustomerName,
            ProductName = command.ProductName,
            Quantity = command.Quantity,
            Price = command.Price,
            TotalAmount = command.Quantity * command.Price,
            CreatedAt = DateTime.UtcNow,
            Status = OrderStatus.Created
        };

        // 2. Persist to repository (gets ID from database)
        var createdOrder = await _orderRepository.AddAsync(order, cancellationToken);

        // 3. Dispatch DOMAIN EVENT (synchronous, same transaction)
        //    Handler will create OrderLineItems using createdOrder.Id
        await _domainEventDispatcher.Dispatch(
            new EntityCreatedEvent(
                createdOrder.Id,      // â† ID from first insert
                nameof(Order),
                null));

        // 4. Publish APPLICATION EVENT (async, fire-and-forget)
        //    Background handlers will send notifications
        await _eventPublisher.PublishAsync(
            new OrderCreatedEvent(
                createdOrder.Id,
                createdOrder.CustomerName,
                createdOrder.TotalAmount),
            cancellationToken);

        // 5. Commit transaction - Both Order AND OrderLineItems are saved together
        // Note: In real app with UoW, you'd call await _unitOfWork.SaveChangesAsync()
        // The repository's SaveChangesAsync is called automatically

        return Result<OrderCreatedResult>.Success(
            new OrderCreatedResult(
                createdOrder.Id,
                createdOrder.CreatedAt,
                createdOrder.TotalAmount));
    }
}
```

#### 3. Domain Event Handler (TestInfrastructure)

```csharp
// OrderLineItemsCreationHandler.cs
public class OrderLineItemsCreationHandler : IDomainEventHandler<EntityCreatedEvent>
{
    private readonly IRepository<OrderLineItem> _lineItemRepository;
    private readonly IRepository<Order> _orderRepository;

    public async Task HandleAsync(
        EntityCreatedEvent domainEvent,
        CancellationToken cancellationToken = default)
    {
        // Only handle Order creation events
        if (domainEvent.EntityType != nameof(Order))
            return;

        // Get the created order
        var order = await _orderRepository.GetByIdAsync(
            domainEvent.EntityId,
            cancellationToken);

        if (order == null) return;

        // Create line items using Order.Id from first insert
        var lineItems = new List<OrderLineItem>
        {
            new OrderLineItem
            {
                Id = 0, // Will be set by database
                OrderId = order.Id, // â† Uses ID from first insert!
                ProductName = order.ProductName,
                Quantity = order.Quantity,
                UnitPrice = order.Price,
                LineTotal = order.TotalAmount,
                CreatedAt = DateTime.UtcNow
            }
        };

        // Add to repository (still in same transaction)
        foreach (var lineItem in lineItems)
        {
            await _lineItemRepository.AddAsync(lineItem, cancellationToken);
        }

        // IMPORTANT: Don't call SaveChangesAsync here!
        // The UnitOfWork/DbContext will commit BOTH inserts together
        // If this handler throws an exception, BOTH inserts are rolled back
    }
}
```

#### 4. DI Registration (TestApi)

```csharp
// ProgramExtensions.cs
public static IServiceCollection AddBusinessServices(this IServiceCollection services)
{
    // 1. Register Domain Event Dispatcher
    services.AddDomainEventDispatcher();

    // 2. Register domain event handlers (scoped - same lifetime as DbContext)
    services.AddDomainEventHandler<EntityCreatedEvent, OrderLineItemsCreationHandler>();
    services.AddDomainEventHandler<EntityCreatedEvent, EntityAuditHandler>();

    return services;
}
```

### Transaction Flow

```
BEGIN TRANSACTION

1. INSERT INTO Orders (...) VALUES (...)
   â†’ Order.Id = 123 (generated by database)

2. Domain Event Dispatched: EntityCreatedEvent(123, "Order")

3. OrderLineItemsCreationHandler.HandleAsync() executes

4. INSERT INTO OrderLineItems (OrderId, ...) VALUES (123, ...)
   â†’ Uses Order.Id = 123 from step 1

5. COMMIT TRANSACTION
   âœ… Both Order and OrderLineItems saved together

   If step 4 fails â†’ ROLLBACK
   âŒ Neither Order nor OrderLineItems are saved
```

---

## Example 2: Application Event Bus (Async)

### Problem Statement
**Need**: Send email notification, log analytics, and trigger workflows when an order is created.

**Challenge**: These operations are I/O intensive and shouldn't block the main request.

**Solution**: Application Event Bus with async background handlers.

### Code Flow

#### 1. Application Event (TestDomain/Events)

```csharp
// OrderEvents.cs
// NOTE: Does NOT inherit from IDomainEvent (it's for application event bus)
public record OrderCreatedEvent(
    int OrderId,
    string CustomerName,
    decimal TotalAmount);
```

#### 2. Publish Event (TestApplication)

```csharp
// OrderService.cs
public async Task<Result<OrderCreatedResult>> CreateOrderAsync(
    CreateOrderCommand command,
    CancellationToken cancellationToken = default)
{
    // ... create and save order ...

    // Publish to Application Event Bus (async, fire-and-forget)
    await _eventPublisher.PublishAsync(
        new OrderCreatedEvent(
            createdOrder.Id,
            createdOrder.CustomerName,
            createdOrder.TotalAmount),
        cancellationToken);

    return Result.Success(...);
}
```

#### 3. Background Event Handlers (TestInfrastructure)

```csharp
// OrderNotificationHandler.cs
public class OrderNotificationHandler : BackgroundService
{
    private readonly IEventSubscriber _eventSubscriber;
    private readonly ILogger<OrderNotificationHandler> _logger;

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("Order Notification Handler started");

        await _eventSubscriber.SubscribeAsync<OrderCreatedEvent>(async (evt, ct) =>
        {
            try
            {
                _logger.LogInformation(
                    "Sending order confirmation email to {CustomerName} for Order {OrderId}",
                    evt.CustomerName,
                    evt.OrderId);

                // Simulate sending email (in real app, use IEmailService)
                await Task.Delay(100, ct);

                _logger.LogInformation(
                    "Order confirmation email sent for Order {OrderId}",
                    evt.OrderId);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error sending notification for Order {OrderId}", evt.OrderId);
                // Could retry or log to dead letter queue
            }
        }, stoppingToken);
    }
}

// OrderAnalyticsHandler.cs
public class OrderAnalyticsHandler : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        await _eventSubscriber.SubscribeAsync<OrderCreatedEvent>(async (evt, ct) =>
        {
            // Log to analytics system
            _logger.LogInformation(
                "Analytics: New order {OrderId} - Total: {Total:C}",
                evt.OrderId,
                evt.TotalAmount);

            // Send to analytics service (Google Analytics, Mixpanel, etc.)
            await Task.CompletedTask;
        }, stoppingToken);
    }
}
```

#### 4. DI Registration (TestApi)

```csharp
// ProgramExtensions.cs
public static IServiceCollection AddBusinessServices(this IServiceCollection services)
{
    // Register Application Event Bus
    services.AddInMemoryEventBus(options =>
    {
        options.EnableDiagnosticLogging = true;
    });

    // Register background event handlers as HostedServices
    services.AddHostedService<OrderNotificationHandler>();
    services.AddHostedService<OrderAnalyticsHandler>();
    services.AddHostedService<OrderWorkflowHandler>();

    return services;
}
```

---

## Complete Example: Both Systems Together

### API Endpoint

```csharp
// OrderEndpoints.cs
app.MapPost("/api/orders/create", async (
    CreateOrderCommand command,
    IOrderService orderService) =>
{
    var result = await orderService.CreateOrderAsync(command);

    return result.Match(
        success: order => Results.Ok(order),
        failure: error => Results.BadRequest(error));
})
.WithName("CreateOrder")
.WithOpenApi();
```

### Request

```bash
POST /api/orders/create
Content-Type: application/json

{
  "customerName": "John Doe",
  "productName": "Laptop",
  "quantity": 2,
  "price": 999.99
}
```

### Execution Flow

```
1. âœ… POST /api/orders/create received

2. âœ… OrderService.CreateOrderAsync() called

3. âœ… Order entity created and saved
   â””â”€> Order.Id = 123 (from database)

4. âœ… Domain Event Dispatched (SYNCHRONOUS)
   â””â”€> EntityCreatedEvent(123, "Order")
       â””â”€> OrderLineItemsCreationHandler executes
           â””â”€> Creates OrderLineItem with OrderId = 123
           â””â”€> Still in same transaction

5. âœ… Application Event Published (ASYNC)
   â””â”€> OrderCreatedEvent(123, "John Doe", 1999.98)
       â””â”€> Queued in channel for background processing

6. âœ… Transaction Committed
   â””â”€> Both Order AND OrderLineItems saved to database

7. âœ… HTTP 200 OK returned to client
   {
     "orderId": 123,
     "createdAt": "2025-12-05T10:30:00Z",
     "totalAmount": 1999.98
   }

8. ğŸ”„ Background Handlers Process Application Event (ASYNC)
   â””â”€> OrderNotificationHandler
       â””â”€> Sends email: "Your order #123 has been confirmed!"
   â””â”€> OrderAnalyticsHandler
       â””â”€> Logs: "Analytics: New order 123 - Total: $1,999.98"
   â””â”€> OrderWorkflowHandler
       â””â”€> Triggers: "Notify warehouse to prepare Order #123"
```

---

## Key Differences Summary

| Aspect | Domain Event Dispatcher | Application Event Bus |
|--------|------------------------|----------------------|
| **Execution** | Synchronous (same transaction) | Asynchronous (background) |
| **Use Case** | Order â†’ OrderLineItems (DB ID dependency) | Email notification, analytics |
| **Consistency** | Strong (ACID transaction) | Eventual (fire-and-forget) |
| **Failure** | Rolls back entire transaction | Already committed, retry logic needed |
| **Performance** | Blocks until handlers complete | Non-blocking, returns immediately |
| **Example** | Create related records using parent ID | Send emails, log metrics, webhooks |

---

## Testing

### Test Domain Event Dispatcher (Transactional)

```bash
# Create order and verify line items are created in same transaction
POST /api/orders/create
{
  "customerName": "John Doe",
  "productName": "Laptop",
  "quantity": 2,
  "price": 999.99
}

# Check database
SELECT * FROM Orders WHERE Id = 123
SELECT * FROM OrderLineItems WHERE OrderId = 123
# âœ… Both records exist - created in same transaction
```

### Test Application Event Bus (Async)

```bash
# Create order
POST /api/orders/create

# Check logs immediately
# âœ… Order created log appears
# âœ… Domain event handler log appears (synchronous)

# Wait 1-2 seconds, check logs again
# âœ… Email notification log appears (async)
# âœ… Analytics log appears (async)
```

---

## Best Practices

### âœ… DO

1. **Use Domain Events for transactional operations**
   - Creating related entities that depend on parent ID
   - Enforcing domain invariants
   - Audit logging that must be atomic

2. **Use Application Events for cross-cutting concerns**
   - Sending notifications (email, SMS, push)
   - Logging analytics
   - Calling external APIs
   - Background workflows

3. **Publish both when appropriate**
   ```csharp
   // Domain event first (synchronous, transactional)
   await _domainEventDispatcher.Dispatch(new EntityCreatedEvent(...));

   // Application event second (async, fire-and-forget)
   await _eventPublisher.PublishAsync(new OrderCreatedEvent(...));
   ```

### âŒ DON'T

1. **Don't use Application Event Bus for transactional operations**
   ```csharp
   // âŒ WRONG - Race condition, no transaction guarantee
   await _eventPublisher.PublishAsync(new CreateLineItemsEvent(orderId));
   ```

2. **Don't call SaveChangesAsync in domain event handlers**
   ```csharp
   // âŒ WRONG - Will commit before main operation completes
   await _lineItemRepository.AddAsync(lineItem);
   await _repository.SaveChangesAsync(); // DON'T DO THIS
   ```

3. **Don't perform I/O in domain event handlers**
   ```csharp
   // âŒ WRONG - Blocks transaction, use application event instead
   public async Task HandleAsync(EntityCreatedEvent evt)
   {
       await _emailService.SendAsync(...); // DON'T DO THIS
   }
   ```

---

## Related Documentation

- [Event Systems Comparison](EVENT_SYSTEMS_COMPARISON.md)
- [Event Bus Guide](EVENT_BUS_GUIDE.md)
- [Clean Architecture Guide](EVENT_BUS_CLEAN_ARCHITECTURE.md)
